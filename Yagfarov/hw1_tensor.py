# -*- coding: utf-8 -*-
"""hw1_tensor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gKjUQ2ccLOmINfJoyRgzHG5Cffl3wpH1

***Имеются 5 тензоров: A, B, C, D, E, которые соединены как на рисунке ниже.***
***Задача: осуществить свертку и выполнить ее тремя способами:***

Cвернуть, используя цикл for;


Вручную используя функции reshape;


Используя пакет ncon;



Сравнить эти способы по:


а) объему написания кода;


б) по времени исполнения;


в) проверить, что эти способы являются равнозначными (сравнения тензеров можно произвести с помощью пакета numpy);


Итогом свертки будет некий тензор R валентности 3.

"""

# загружаем ncon и подключаем библиотеки
! pip install  ncon
import numpy as np
from ncon import ncon
import time

# объявляем случайные тензоры
x = 4
A = np.random.uniform(-1,1, (x,x,x))
B = np.random.uniform(-1,1, (x,x,x,x))
C = np.random.uniform(-1,1, (x,x,x,x))
D = np.random.uniform(-1,1, (x,x,x))
E = np.random.uniform(-1,1, (x,x,x))

# выводим их
A, B, C, D, E

print(A.shape)
print(B.shape)
print(C.shape)
print(D.shape)
print(E.shape)

"""#1. Свёртка с использованием for."""

start1 = time.time()

AC = np.zeros((x, x, x, x, x))
for a in range(x):
  for b in range(x):
    for c in range(x):
      for d in range(x):
        for e in range(x):
          for f in range(x):
            AC[a, b, c, d, e] = AC[a, b, c, d, e] + A[a, b, f] * C[f, c, d, e]
ACB = np.zeros((x, x, x, x, x))
for a in range(x):
  for b in range(x):
    for c in range(x):
      for d in range(x):
        for e in range(x):
          for f in range(x):
            for g in range(x):
              ACB[a, b, c, d, e] = ACB[a, b, c, d, e] + AC[a, f, g, b, c] * B[f, g, e, d]

ACBE = np.zeros((x, x, x, x))
for a in range(x):
  for b in range(x):
    for c in range(x):
      for d in range(x):
        for e in range(x):
          for f in range(x):
            ACBE[a, b, c, d] = ACBE[a, b, c, d] + ACB[a, b, e, c, f] * E[f, e, d]

ACBED  = np.zeros((x, x, x))
for a in range(x):
  for b in range(x):
    for c in range(x):
      for d in range(x):
        for e in range(x):
          ACBED[a, b, c] =  ACBED[a, b, c] + ACBE[a, d, b, e] + D[e, d, c]

end1 = time.time() - start1

answer_for = ACBED
print(ACBED)
print(ACBED.shape)

"""#2. Свёртка с использованием reshape."""

start2 = time.time()

# np.tensordot вычисляет скалярное произведение тензора вдоль заданных осей.
# на вход подаются два тензора a и b, и объект array_like, сожержащий оси в числовом формате.
AC = np.tensordot(A, C, axes=([2],[0]))
ACB = np.tensordot(AC, B, axes=([1,2],[0,1]))
ACBE = np.tensordot(ACB, E, axes=([2,3],[1,0]))
ACBED = np.tensordot(ACBE, D, axes=([1,2],[1,2]))

end2 = time.time() - start2

answer_reshape = ACBED
print(ACBED)
print(ACBED.shape)

"""#3. Свёртка с использованием ncon."""

start3 = time.time()

# первый аргумент L - лист тензоров, второй аргумент v — это список из списка, по одному для каждого тензора в L. 
# каждый v[i]состоит из целых чисел, каждое из которых обозначает индекс L[i].
ABCDE = ncon((A, B, C, D, E),  ([1, 4, -1], [1, 3, 5, -2], [4, 5, 6, 7], [2, 7, -3], [2, 3, 6]))

end3 = time.time() - start3

answer_ncon = ABCDE
print(ACBED)
print(ACBED.shape)

"""#4. Итоги."""

print(f"Время выполнения через for: {end1}")
print(f"Время выполнения через reshape и матричное произведение (reshape): = {end2}")
print(f"Время выполнения через ncon = {end3}")

"""По объему кода самый затратный - for, затем reshape и ncon;

По времени выполнения самый затратный for, затем ncon и reshape.
"""
