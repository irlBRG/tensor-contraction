# -*- coding: utf-8 -*-
"""lab1_Kuzmichev.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b1wHqBSfCtNfxwCj6zYSUeRYGRd-2l1p

Лабораторная №1

Выполнил студент группы М80-107-22 Кузьмичев Александр
"""

!pip install ncon
import time
import numpy as np
from ncon import ncon as nc

"""Зададим тензоры"""

A = np.random.rand(10, 10, 10)
B = np.random.rand(10, 10, 10, 10)
C = np.random.rand(10, 10, 10, 10)
E = np.random.rand(10, 10, 10)
D = np.random.rand(10, 10, 10)

print(f'Shape of tensor A: {A.shape }')
print(f'Shape of tensor B: {B.shape }')
print(f'Shape of tensor C: {C.shape }')
print(f'Shape of tensor D: {D.shape }')
print(f'Shape of tensor E: {E.shape }')

"""## **1 способ:**

Свертка с помощью циклов *for*:
"""

def ForConvolution(A, B, C, D, E):
    AC = np.zeros((10, 10, 10, 10, 10))
    for i in range(10):
        for j in range(10):
            for k in range(10):
                for l in range(10):
                    for m in range(10):
                        for n in range(10): 
                            AC[i, j, k, l, m] = AC[i, j, k, l, m] + A[i, j, n] * C[n, k, l, m]
    ACB = np.zeros((10, 10, 10, 10, 10))
    for i in range(10):
        for j in range(10):
            for k in range(10):
                for l in range(10):
                    for m in range(10):
                        for n in range(10):
                            for p in range(10):  
                                ACB[i, j, k, l, m] = ACB[i, j, k, l, m] + AC[i, n, p, j, k] * B[n, p, m, l]
    ACBE = np.zeros((10, 10, 10, 10))
    for i in range(10):
        for j in range(10):
            for k in range(10):
                for l in range(10):
                    for m in range(10):
                        for n in range(10):
                            ACBE[i, j, k, l] = ACBE[i, j, k, l] + ACB[i, j, m, k, n] * E[n, m, l]
    result  = np.zeros((10, 10, 10))
    for i in range(10):
        for j in range(10):
            for k in range(10):
                for l in range(10):
                    for m in range(10):
                        result[i, j, k] =  result[i, j, k] + ACBE[i, l, j, m] + D[m, l, k]
    return result

start = time.time()
for_conv_res = ForConvolution(A, B, C, D, E)
time_res = time.time() - start
print(for_conv_res)

"""Взглянем на время выполнения:"""

print(time_res)

"""# **2 способ:**

C помощью *reshape*:
"""

def ReshapeConvolution(A, B, C, D, E):
    AC = np.tensordot(A, C, axes=([2],[0]))
    ACB = np.tensordot(AC, B, axes=([1,2],[0,1]))
    ACBE = np.tensordot(ACB, E, axes=([2,3],[1,0]))
    return np.tensordot(ACBE, D, axes=([1,2],[1,2]))

start = time.time()
reshape_conv_res = ReshapeConvolution(A, B, C, D, E)
time_res = time.time() - start
print(reshape_conv_res)

"""Взглянем на время выполнения:"""

print(time_res)

"""# **3 способ:**

С помощью *ncon*:
"""

def NconConvolution(A, B, C, D, E):
  return nc((A, B, C, D, E),
              ([-1, 1, 5],
               [1, 6, 2, -2],
               [5, 6, 4, 7],
               [3, 4, -3],
               [2, 7, 3]))

start = time.time()
ncon_conv_res = NconConvolution(A, B, C, D, E)
time_res = time.time() - start
print(ncon_conv_res)

"""Взглянем на время выполнения:"""

print(time_res)

"""# **Сравнение по времени:**

Сравним три способа свертки по времени. Нетрудно заметить, что самым быстрым способом оказалась свертка с помощью reshape, а самым медленным - с помощью циклов for.

По объему написания кода выигрывает ncon, тогда как свертка с помощью циклов for значительно отстает.
"""